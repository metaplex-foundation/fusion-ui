"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderInstruction = void 0;
const types_1 = require("./types");
const assert_1 = require("assert");
const type_mapper_1 = require("./type-mapper");
const serdes_1 = require("./serdes");
const known_pubkeys_1 = require("./known-pubkeys");
const beet_1 = require("@metaplex-foundation/beet");
const render_enums_1 = require("./render-enums");
const instruction_discriminator_1 = require("./instruction-discriminator");
class InstructionRenderer {
    constructor(ix, fullFileDir, programId, typeMapper) {
        this.ix = ix;
        this.fullFileDir = fullFileDir;
        this.programId = programId;
        this.typeMapper = typeMapper;
        // -----------------
        // Instruction Args Type
        // -----------------
        this.renderIxArgField = (arg) => {
            const typescriptType = this.typeMapper.map(arg.type, arg.name);
            return `${arg.name}: ${typescriptType}`;
        };
        this.upperCamelIxName = ix.name
            .charAt(0)
            .toUpperCase()
            .concat(ix.name.slice(1));
        this.camelIxName = ix.name.charAt(0).toLowerCase().concat(ix.name.slice(1));
        this.argsTypename = `${this.upperCamelIxName}InstructionArgs`;
        this.accountsTypename = `${this.upperCamelIxName}InstructionAccounts`;
        this.instructionDiscriminatorName = `${this.camelIxName}InstructionDiscriminator`;
        this.structArgName = `${ix.name}Struct`;
        this.instructionDiscriminator = new instruction_discriminator_1.InstructionDiscriminator(ix, 'instructionDiscriminator', typeMapper);
        this.programIdPubkey = `new ${types_1.SOLANA_WEB3_EXPORT_NAME}.PublicKey('${this.programId}')`;
    }
    renderIxArgsType() {
        if (this.ix.args.length === 0)
            return '';
        const fields = this.ix.args
            .map((field) => this.renderIxArgField(field))
            .join(',\n  ');
        const code = `
/**
 * @category Instructions
 * @category ${this.upperCamelIxName}
 * @category generated
 */
export type ${this.argsTypename} = {
  ${fields}
}`.trim();
        return code;
    }
    // -----------------
    // Imports
    // -----------------
    renderImports(processedKeys) {
        const typeMapperImports = this.typeMapper.importsUsed(this.fullFileDir.toString(), new Set([types_1.SOLANA_WEB3_PACKAGE, beet_1.BEET_PACKAGE]));
        const needsSplToken = processedKeys.some((x) => { var _a; return ((_a = x.knownPubkey) === null || _a === void 0 ? void 0 : _a.pack) === types_1.SOLANA_SPL_TOKEN_PACKAGE; });
        const splToken = needsSplToken
            ? `\nimport * as ${types_1.SOLANA_SPL_TOKEN_EXPORT_NAME} from '${types_1.SOLANA_SPL_TOKEN_PACKAGE}';`
            : '';
        return `
${splToken}
${typeMapperImports.join('\n')}`.trim();
    }
    // -----------------
    // Accounts
    // -----------------
    processIxAccounts() {
        return this.ix.accounts.map((acc) => {
            var _a;
            const knownPubkey = (0, known_pubkeys_1.resolveKnownPubkey)(acc.name);
            const optional = (_a = acc.optional) !== null && _a !== void 0 ? _a : false;
            return knownPubkey == null
                ? { ...acc, optional }
                : { ...acc, knownPubkey, optional };
        });
    }
    renderIxAccountKeys(processedKeys) {
        const requireds = processedKeys.filter((x) => !x.optional);
        const optionals = processedKeys.filter((x, idx) => {
            if (!x.optional)
                return false;
            (0, assert_1.strict)(idx >= requireds.length, `All optional accounts need to follow required accounts, ${x.name} is not`);
            return true;
        });
        const requiredKeys = requireds
            .map(({ name, isMut, isSigner, knownPubkey }) => {
            const pubkey = knownPubkey == null
                ? `accounts.${name}`
                : `accounts.${name} ?? ${(0, known_pubkeys_1.renderKnownPubkeyAccess)(knownPubkey, this.programIdPubkey)}`;
            return `{
      pubkey: ${pubkey},
      isWritable: ${isMut.toString()},
      isSigner: ${isSigner.toString()},
    }`;
        })
            .join(',\n    ');
        const optionalKeys = optionals.length > 0
            ? optionals
                .map(({ name, isMut, isSigner }, idx) => {
                const requiredOptionals = optionals.slice(0, idx);
                const requiredChecks = requiredOptionals
                    .map((x) => `accounts.${x.name} == null`)
                    .join(' || ');
                const checkRequireds = requiredChecks.length > 0
                    ? `if (${requiredChecks}) { throw new Error('When providing \\'${name}\\' then ` +
                        `${requiredOptionals
                            .map((x) => `\\'accounts.${x.name}\\'`)
                            .join(', ')} need(s) to be provided as well.') }`
                    : '';
                // NOTE: we purposely don't add the default resolution here since the intent is to
                // only pass that account when it is provided
                return `
  if (accounts.${name} != null) {
    ${checkRequireds}
    keys.push({
      pubkey: accounts.${name},
      isWritable: ${isMut.toString()},
      isSigner: ${isSigner.toString()},
    })
  }`;
            })
                .join('\n') + '\n'
            : '';
        return `[\n    ${requiredKeys}\n  ]\n${optionalKeys}\n`;
    }
    renderAccountsType(processedKeys) {
        if (processedKeys.length === 0)
            return '';
        const web3 = types_1.SOLANA_WEB3_EXPORT_NAME;
        const fields = processedKeys
            .map((x) => {
            if (x.knownPubkey != null) {
                return `${x.name}?: ${web3}.PublicKey`;
            }
            const optional = x.optional ? '?' : '';
            return `${x.name}${optional}: ${web3}.PublicKey`;
        })
            .join('\n  ');
        const propertyComments = processedKeys
            // known pubkeys are not provided by the user and thus aren't part of the type
            .filter((x) => !(0, known_pubkeys_1.isKnownPubkey)(x.name))
            .map((x) => {
            const attrs = [];
            if (x.isMut)
                attrs.push('_writable_');
            if (x.isSigner)
                attrs.push('**signer**');
            const optional = x.optional ? ' (optional) ' : ' ';
            const desc = (0, types_1.isIdlInstructionAccountWithDesc)(x) ? x.desc : '';
            return (`* @property [${attrs.join(', ')}] ` + `${x.name}${optional}${desc} `);
        });
        const properties = propertyComments.length > 0
            ? `\n *\n  ${propertyComments.join('\n')} `
            : '';
        const docs = `
/**
  * Accounts required by the _${this.ix.name}_ instruction${properties}
  * @category Instructions
  * @category ${this.upperCamelIxName}
  * @category generated
  */
`.trim();
        return `${docs}
          export type ${this.accountsTypename} = {
  ${fields}
        }
        `;
    }
    renderAccountsParamDoc(processedKeys) {
        if (processedKeys.length === 0)
            return '  *';
        return `  *
  * @param accounts that will be accessed while the instruction is processed`;
    }
    renderAccountsArg(processedKeys) {
        if (processedKeys.length === 0)
            return '';
        return `accounts: ${this.accountsTypename}, \n`;
    }
    // -----------------
    // Data Struct
    // -----------------
    serdeProcess() {
        return this.typeMapper.mapSerdeFields(this.ix.args);
    }
    renderDataStruct(args) {
        const discriminatorField = this.typeMapper.mapSerdeField(this.instructionDiscriminator.getField());
        const discriminatorType = this.instructionDiscriminator.renderType();
        const struct = (0, serdes_1.renderDataStruct)({
            fields: args,
            discriminatorName: 'instructionDiscriminator',
            discriminatorField,
            discriminatorType,
            structVarName: this.structArgName,
            argsTypename: this.argsTypename,
            isFixable: this.typeMapper.usedFixableSerde,
        });
        return `
/**
 * @category Instructions
 * @category ${this.upperCamelIxName}
 * @category generated
 */
${struct} `.trim();
    }
    render() {
        this.typeMapper.clearUsages();
        const ixArgType = this.renderIxArgsType();
        const processedKeys = this.processIxAccounts();
        const accountsType = this.renderAccountsType(processedKeys);
        const processedArgs = this.serdeProcess();
        const argsStructType = this.renderDataStruct(processedArgs);
        const keys = this.renderIxAccountKeys(processedKeys);
        const accountsParamDoc = this.renderAccountsParamDoc(processedKeys);
        const accountsArg = this.renderAccountsArg(processedKeys);
        const instructionDisc = this.instructionDiscriminator.renderValue();
        const enums = (0, render_enums_1.renderScalarEnums)(this.typeMapper.scalarEnumsUsed).join('\n');
        const web3 = types_1.SOLANA_WEB3_EXPORT_NAME;
        const imports = this.renderImports(processedKeys);
        const [createInstructionArgsComment, createInstructionArgs, createInstructionArgsSpread, comma,] = this.ix.args.length === 0
            ? ['', '', '', '']
            : [
                `\n * @param args to provide as instruction data to the program\n * `,
                `args: ${this.argsTypename} `,
                '...args',
                ', ',
            ];
        const programIdArg = `${comma}programId = ${this.programIdPubkey}`;
        return `${imports}

${enums}
${ixArgType}
${argsStructType}
${accountsType}
    export const ${this.instructionDiscriminatorName} = ${instructionDisc};

    /**
     * Creates a _${this.upperCamelIxName}_ instruction.
    ${accountsParamDoc}${createInstructionArgsComment}
     * @category Instructions
     * @category ${this.upperCamelIxName}
     * @category generated
     */
    export function create${this.upperCamelIxName}Instruction(
      ${accountsArg}${createInstructionArgs}${programIdArg}
    ) {
      const [data] = ${this.structArgName}.serialize({
        instructionDiscriminator: ${this.instructionDiscriminatorName},
    ${createInstructionArgsSpread}
    });
    const keys: ${web3}.AccountMeta[] = ${keys}
    const ix = new ${web3}.TransactionInstruction({
      programId,
      keys,
      data
  });
  return ix; 
}
`;
    }
}
function renderInstruction(ix, fullFileDir, programId, accountFilesByType, customFilesByType, typeAliases, forceFixable) {
    const typeMapper = new type_mapper_1.TypeMapper(accountFilesByType, customFilesByType, typeAliases, forceFixable);
    const renderer = new InstructionRenderer(ix, fullFileDir, programId, typeMapper);
    return renderer.render();
}
exports.renderInstruction = renderInstruction;
//# sourceMappingURL=render-instruction.js.map