"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleShank = exports.handleAnchor = void 0;
const rustbin_1 = require("@metaplex-foundation/rustbin");
const child_process_1 = require("child_process");
const path_1 = __importDefault(require("path"));
const enhance_idl_1 = require("./enhance-idl");
const gen_typescript_1 = require("./gen-typescript");
const utils_1 = require("../utils");
function handleAnchor(config, prettierConfig) {
    const { idlDir, binaryInstallDir, programDir } = config;
    const spawnArgs = ['build', '--idl', idlDir];
    const spawnOpts = {
        cwd: programDir,
    };
    const rustbinConfig = {
        rootDir: binaryInstallDir,
        binaryName: 'anchor',
        binaryCrateName: 'anchor-cli',
        libName: 'anchor-lang',
        cargoToml: path_1.default.join(programDir, 'Cargo.toml'),
        dryRun: false,
        ...config.rustbin,
    };
    return handle(config, rustbinConfig, spawnArgs, spawnOpts, prettierConfig);
}
exports.handleAnchor = handleAnchor;
function handleShank(config, prettierConfig) {
    const { idlDir, binaryInstallDir, programDir } = config;
    const spawnArgs = ['idl', '--out-dir', idlDir, '--crate-root', programDir];
    const spawnOpts = {
        cwd: programDir,
    };
    const rustbinConfig = {
        rootDir: binaryInstallDir,
        binaryName: 'shank',
        binaryCrateName: 'shank-cli',
        libName: 'shank',
        cargoToml: path_1.default.join(programDir, 'Cargo.toml'),
        dryRun: false,
    };
    return handle(config, rustbinConfig, spawnArgs, spawnOpts, prettierConfig);
}
exports.handleShank = handleShank;
async function handle(config, rustbinConfig, spawnArgs, spawnOpts, prettierConfig) {
    const { programName, idlDir, sdkDir } = config;
    const { fullPathToBinary, binVersion, libVersion } = await (0, rustbin_1.rustbinMatch)(rustbinConfig, confirmAutoMessageLog);
    if (binVersion == null) {
        throw new Error(`rustbin was unable to determine installed version ${rustbinConfig.binaryName}, it may ` +
            `not have been installed correctly.`);
    }
    return new Promise((resolve, reject) => {
        const idlGenerator = (0, child_process_1.spawn)(fullPathToBinary, spawnArgs, spawnOpts)
            .on('error', (err) => {
            (0, utils_1.logError)(`${programName} idl generation failed`);
            reject(err);
        })
            .on('exit', async () => {
            (0, utils_1.logInfo)('IDL written to: %s', path_1.default.join(idlDir, `${programName}.json`));
            const idl = await (0, enhance_idl_1.enhanceIdl)(config, binVersion, libVersion);
            await (0, gen_typescript_1.generateTypeScriptSDK)(idl, sdkDir, prettierConfig, config.typeAliases, config.serializers);
            resolve();
        });
        idlGenerator.stdout.on('data', (buf) => process.stdout.write(buf));
        idlGenerator.stderr.on('data', (buf) => process.stderr.write(buf));
    });
}
function confirmAutoMessageLog({ binaryName, libVersion, libName, binVersion, fullPathToBinary, }) {
    if (binVersion == null) {
        (0, utils_1.logInfo)(`No existing version found for ${binaryName}.`);
    }
    else {
        (0, utils_1.logInfo)(`Version for ${binaryName}: ${binVersion}`);
    }
    (0, utils_1.logInfo)(`Will install version matching "${libName}: '${libVersion}'" to ${fullPathToBinary}`);
    return Promise.resolve(true);
}
//# sourceMappingURL=handlers.js.map